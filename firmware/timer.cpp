/* timer.h
 * Создан: 02.04.2024 12:10:47
 * Нижегородский Государственный технический университет им. Р.Е. Алексеева
 * группа 22-ВМв Хаченков О.И. 
 * Объект этого класса генерирует в фоновом режиме заданные промежутки времени, 
 * через которые должно выполняться какое либо действие.
 */ 
#include "timer.h"
															//переменную, которая будет инкрементироваться в обработчике 
															//прерывания TIMER1_COMPA_vect с интервалом в одну миллисекунду.
Time::Time(){
															//Конструктор объекта
	TIMSK|=1<<OCIE1A;										//Разрешение прерывания от таймера при совпадении OCR1A и TCNT1,
	TCCR1B|= 1 << CS00;										//запуск счетчика с коэффициентом деления 1,
	OCR1A = F_CPU/1000;										//установка значения, соответствующего 1 миллисекунде.
	flagOn = false;											//Флаг срабатывания таймера, сброшен при создании.
	sei();													//Глобальное разрешение прерывания.
}
void Time::delayStart(uint32_t MS){							//Запуск таймера с установленной выдержкой
	if (flagOn == false){									//Если таймер еще не был запущен, 
		ms = MS;											//устанавливается время,
		tmp = timeCounter;									//сохраняется текущее состояние переменной текущего времени,
		flagOn = true;										//устанавливается флаг работы таймера.
	}
}
void Time::delayStop(){										//Остановка таймера, независимо от того, 
	flagOn = false;											//вышел ли заданный интервал времени или нет.
}	
bool Time::delayEnd(){										//Данный метод проверяет, истек ли промежуток времени или нет.
	if (flagOn == true){									//Если таймер был запущен,
		uint64_t m = timeCounter - tmp;						//Вычисляется разность между сохраненным значение времени и фактическим значением.
		if (((timeCounter > tmp) &&							//Если текущее значение больше ранее сохраненного, то
			 (timeCounter - tmp >= ms)) ||					//интервал времени вычисляется как разность.
		    ((timeCounter < tmp) &&							//Если текущее значение времени меньше сохранённого,
			 (UINT64_MAX - tmp + timeCounter >= ms))){		//значит было переполнение, и интервал времени вычисляется с учетом переполнения.
			flagOn = false;									//Устанавливается флаг остановки таймера, таймер готов к повторному использованию.
			return true;									//Интервал времени истек.
		}
	}
	return false;											//Интервал времени не истек.
}
